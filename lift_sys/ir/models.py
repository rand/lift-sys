"""Intermediate Representation (IR) data structures."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import UTC, datetime
from enum import Enum
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from lift_sys.ir.constraints import Constraint


class HoleKind(str, Enum):
    """Enumeration describing the semantic purpose of a typed hole."""

    INTENT = "intent"
    SIGNATURE = "signature"
    EFFECT = "effect"
    ASSERTION = "assertion"
    IMPLEMENTATION = "implementation"


class ProvenanceSource(str, Enum):
    """Source/origin of an IR element."""

    HUMAN = "human"  # Created by human user
    AGENT = "agent"  # Created by AI agent
    REVERSE = "reverse"  # Extracted from code by reverse mode
    VERIFICATION = "verification"  # Generated by verification/testing
    MERGE = "merge"  # Result of merging multiple versions
    REFINEMENT = "refinement"  # Result of refining a hole or specification
    UNKNOWN = "unknown"  # Source not tracked


@dataclass(slots=True)
class Provenance:
    """
    Tracks the origin and confidence of an IR element.

    Provenance enables:
    - Understanding where each element came from
    - Tracking confidence in automatically generated elements
    - Auditing changes and authorship
    - Supporting evidence-based verification
    """

    source: ProvenanceSource = ProvenanceSource.UNKNOWN
    """Who or what created this element."""

    confidence: float = 1.0
    """Confidence score (0.0 to 1.0). 1.0 = fully confident, 0.0 = uncertain."""

    timestamp: str = field(default_factory=lambda: datetime.now(UTC).isoformat() + "Z")
    """When this element was created (ISO 8601 format)."""

    author: str | None = None
    """Author identifier (user ID, agent name, system name, etc.)."""

    evidence_refs: list[str] = field(default_factory=list)
    """References to evidence supporting this element (e.g., evidence IDs from metadata)."""

    metadata: dict[str, Any] = field(default_factory=dict)
    """Additional provenance metadata (e.g., model version, commit hash, etc.)."""

    def to_dict(self) -> dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "source": self.source.value,
            "confidence": self.confidence,
            "timestamp": self.timestamp,
            "author": self.author,
            "evidence_refs": self.evidence_refs,
            "metadata": self.metadata,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> Provenance:
        """Deserialize from dictionary."""
        return cls(
            source=ProvenanceSource(data.get("source", ProvenanceSource.UNKNOWN.value)),
            confidence=data.get("confidence", 1.0),
            timestamp=data.get("timestamp", datetime.now(UTC).isoformat() + "Z"),
            author=data.get("author"),
            evidence_refs=data.get("evidence_refs", []),
            metadata=data.get("metadata", {}),
        )

    @classmethod
    def from_human(cls, author: str | None = None, **kwargs) -> Provenance:
        """Create provenance for human-authored element."""
        return cls(source=ProvenanceSource.HUMAN, confidence=1.0, author=author, **kwargs)

    @classmethod
    def from_agent(cls, author: str | None = None, confidence: float = 0.9, **kwargs) -> Provenance:
        """Create provenance for agent-generated element."""
        return cls(source=ProvenanceSource.AGENT, confidence=confidence, author=author, **kwargs)

    @classmethod
    def from_reverse(cls, evidence_refs: list[str] | None = None, **kwargs) -> Provenance:
        """Create provenance for reverse-mode extracted element."""
        return cls(
            source=ProvenanceSource.REVERSE,
            confidence=0.85,
            evidence_refs=evidence_refs or [],
            **kwargs,
        )

    @classmethod
    def from_merge(cls, author: str | None = None, **kwargs) -> Provenance:
        """Create provenance for merged element."""
        return cls(source=ProvenanceSource.MERGE, author=author, **kwargs)


@dataclass(slots=True)
class TypedHole:
    """Explicit representation of an unknown value in the IR."""

    identifier: str
    type_hint: str
    description: str = ""
    constraints: dict[str, str] = field(default_factory=dict)
    kind: HoleKind = HoleKind.INTENT

    def label(self) -> str:
        """Return a human friendly label for visualisations."""

        return f"<?{self.identifier}: {self.type_hint}?>"

    def to_dict(self) -> dict[str, object]:
        return {
            "identifier": self.identifier,
            "type_hint": self.type_hint,
            "description": self.description,
            "constraints": self.constraints,
            "kind": self.kind.value,
        }


@dataclass(slots=True)
class IntentClause:
    summary: str
    rationale: str | None = None
    holes: list[TypedHole] = field(default_factory=list)
    provenance: Provenance | None = None

    def to_dict(self) -> dict[str, object]:
        result = {
            "summary": self.summary,
            "rationale": self.rationale,
            "holes": [hole.to_dict() for hole in self.holes],
        }
        if self.provenance:
            result["provenance"] = self.provenance.to_dict()
        return result


@dataclass(slots=True)
class Parameter:
    name: str
    type_hint: str
    description: str | None = None
    provenance: Provenance | None = None

    def to_dict(self) -> dict[str, object]:
        result = {
            "name": self.name,
            "type_hint": self.type_hint,
            "description": self.description,
        }
        if self.provenance:
            result["provenance"] = self.provenance.to_dict()
        return result


@dataclass(slots=True)
class SigClause:
    name: str
    parameters: list[Parameter]
    returns: str | None
    holes: list[TypedHole] = field(default_factory=list)
    provenance: Provenance | None = None

    def to_dict(self) -> dict[str, object]:
        result = {
            "name": self.name,
            "parameters": [param.to_dict() for param in self.parameters],
            "returns": self.returns,
            "holes": [hole.to_dict() for hole in self.holes],
        }
        if self.provenance:
            result["provenance"] = self.provenance.to_dict()
        return result


@dataclass(slots=True)
class EffectClause:
    description: str
    holes: list[TypedHole] = field(default_factory=list)
    provenance: Provenance | None = None

    def to_dict(self) -> dict[str, object]:
        result = {
            "description": self.description,
            "holes": [hole.to_dict() for hole in self.holes],
        }
        if self.provenance:
            result["provenance"] = self.provenance.to_dict()
        return result


@dataclass(slots=True)
class AssertClause:
    predicate: str
    rationale: str | None = None
    holes: list[TypedHole] = field(default_factory=list)
    provenance: Provenance | None = None

    def to_dict(self) -> dict[str, object]:
        result = {
            "predicate": self.predicate,
            "rationale": self.rationale,
            "holes": [hole.to_dict() for hole in self.holes],
        }
        if self.provenance:
            result["provenance"] = self.provenance.to_dict()
        return result


@dataclass(slots=True)
class RelationshipClause:
    """
    Represents a relationship between entities extracted from natural language.

    Phase 2 Enhancement: Structured relationship extraction for semantic analysis.

    Relationships capture connections between entities mentioned in the prompt:
    - Dependencies: "X depends on Y", "X requires Y", "X uses Y"
    - Creation: "X creates Y", "X generates Y", "X produces Y"
    - Modification: "X modifies Y", "X updates Y", "X changes Y"
    - Temporal: "X before Y", "X after Y", "X triggers Y"
    - Causal: "X causes Y", "X results in Y", "if X then Y"
    - Composition: "X contains Y", "X includes Y", "X is part of Y"

    Example:
        RelationshipClause(
            from_entity="validate",
            to_entity="email",
            relationship_type="OPERATES_ON",
            confidence=0.9,
            description="Validate operates on email input"
        )
    """

    from_entity: str
    """Source entity in the relationship"""

    to_entity: str
    """Target entity in the relationship"""

    relationship_type: str
    """Type of relationship (USES, PRODUCES, DEPENDS_ON, MODIFIES, etc.)"""

    confidence: float = 0.8
    """Confidence score for this relationship extraction (0.0-1.0)"""

    description: str = ""
    """Human-readable description of the relationship"""

    holes: list[TypedHole] = field(default_factory=list)
    provenance: Provenance | None = None

    def to_dict(self) -> dict[str, object]:
        result = {
            "from_entity": self.from_entity,
            "to_entity": self.to_entity,
            "relationship_type": self.relationship_type,
            "confidence": self.confidence,
            "description": self.description,
            "holes": [hole.to_dict() for hole in self.holes],
        }
        if self.provenance:
            result["provenance"] = self.provenance.to_dict()
        return result


@dataclass(slots=True)
class Metadata:
    source_path: str | None = None
    language: str | None = None
    origin: str | None = None
    evidence: list[dict[str, object]] = field(default_factory=list)

    def to_dict(self) -> dict[str, object]:
        return {
            "source_path": self.source_path,
            "language": self.language,
            "origin": self.origin,
            "evidence": self.evidence,
        }


@dataclass(slots=True)
class IntermediateRepresentation:
    """The single source of truth for a lifted specification."""

    intent: IntentClause
    signature: SigClause
    effects: list[EffectClause] = field(default_factory=list)
    assertions: list[AssertClause] = field(default_factory=list)
    relationships: list[RelationshipClause] = field(default_factory=list)
    """Phase 2: Structured relationships between entities"""
    metadata: Metadata = field(default_factory=Metadata)
    constraints: list[Constraint] = field(default_factory=list)
    """Phase 7: Explicit constraints on code generation behavior"""

    def typed_holes(self) -> list[TypedHole]:
        """Return every typed hole contained within the IR."""

        holes: list[TypedHole] = []
        holes.extend(self.intent.holes)
        holes.extend(self.signature.holes)
        for param in self.signature.parameters:
            if isinstance(param, TypedHole):  # pragma: no cover - defensive
                holes.append(param)
        for effect in self.effects:
            holes.extend(effect.holes)
        for assertion in self.assertions:
            holes.extend(assertion.holes)
        for relationship in self.relationships:
            holes.extend(relationship.holes)
        return holes

    def to_dict(self) -> dict[str, object]:
        """Serialise the IR into a dictionary suitable for APIs."""

        result = {
            "intent": self.intent.to_dict(),
            "signature": self.signature.to_dict(),
            "effects": [eff.to_dict() for eff in self.effects],
            "assertions": [assertion.to_dict() for assertion in self.assertions],
            "metadata": self.metadata.to_dict(),
        }

        # Add relationships if present (Phase 2)
        if self.relationships:
            result["relationships"] = [rel.to_dict() for rel in self.relationships]

        # Add constraints if present (Phase 7)
        if self.constraints:
            result["constraints"] = [constraint.to_dict() for constraint in self.constraints]

        return result

    @classmethod
    def from_dict(cls, payload: dict[str, object]) -> IntermediateRepresentation:
        """Create an IR instance from a dictionary."""

        intent_data = payload["intent"]
        signature_data = payload["signature"]

        def parse_holes(data: list[dict[str, object]]) -> list[TypedHole]:
            holes = []
            for hole_data in data:
                if isinstance(hole_data, dict):
                    # Handle kind field conversion
                    kind = hole_data.get("kind", HoleKind.INTENT.value)
                    if isinstance(kind, str):
                        kind = HoleKind(kind)
                    hole = TypedHole(
                        identifier=hole_data["identifier"],
                        type_hint=hole_data["type_hint"],
                        description=hole_data.get("description", ""),
                        constraints=hole_data.get("constraints", {}),
                        kind=kind,
                    )
                    holes.append(hole)
                else:
                    holes.append(hole_data)
            return holes

        def parse_provenance(data: dict[str, object] | None) -> Provenance | None:
            if not data:
                return None
            return Provenance.from_dict(data)

        intent = IntentClause(
            summary=intent_data["summary"],
            rationale=intent_data.get("rationale"),
            holes=parse_holes(intent_data.get("holes", [])),
            provenance=parse_provenance(intent_data.get("provenance")),
        )

        # Parse parameters with provenance
        parameters = []
        for param in signature_data.get("parameters", []):
            if isinstance(param, dict):
                parameters.append(
                    Parameter(
                        name=param["name"],
                        type_hint=param["type_hint"],
                        description=param.get("description"),
                        provenance=parse_provenance(param.get("provenance")),
                    )
                )
            else:
                parameters.append(param)

        signature = SigClause(
            name=signature_data["name"],
            parameters=parameters,
            returns=signature_data.get("returns"),
            holes=parse_holes(signature_data.get("holes", [])),
            provenance=parse_provenance(signature_data.get("provenance")),
        )

        # Handle both string effects (legacy) and dict effects (new format)
        effects = []
        for effect in payload.get("effects", []):
            if isinstance(effect, str):
                # Legacy format: effects are strings
                effects.append(EffectClause(description=effect))
            else:
                # New format: effects are dicts
                effects.append(
                    EffectClause(
                        description=effect["description"],
                        holes=parse_holes(effect.get("holes", [])),
                        provenance=parse_provenance(effect.get("provenance")),
                    )
                )

        assertions = [
            AssertClause(
                predicate=assertion["predicate"],
                rationale=assertion.get("rationale"),
                holes=parse_holes(assertion.get("holes", [])),
                provenance=parse_provenance(assertion.get("provenance")),
            )
            for assertion in payload.get("assertions", [])
        ]

        # Parse relationships (Phase 2)
        relationships = [
            RelationshipClause(
                from_entity=rel["from_entity"],
                to_entity=rel["to_entity"],
                relationship_type=rel["relationship_type"],
                confidence=rel.get("confidence", 0.8),
                description=rel.get("description", ""),
                holes=parse_holes(rel.get("holes", [])),
                provenance=parse_provenance(rel.get("provenance")),
            )
            for rel in payload.get("relationships", [])
        ]

        metadata_payload = payload.get("metadata", {}) or {}
        metadata = Metadata(
            source_path=metadata_payload.get("source_path"),
            language=metadata_payload.get("language"),
            origin=metadata_payload.get("origin"),
            evidence=list(metadata_payload.get("evidence", [])),
        )

        # Parse constraints (Phase 7)
        constraints = []
        if "constraints" in payload:
            from lift_sys.ir.constraints import parse_constraint

            for constraint_data in payload["constraints"]:
                try:
                    constraint = parse_constraint(constraint_data)
                    constraints.append(constraint)
                except (KeyError, ValueError) as e:
                    # Skip invalid constraints but log
                    print(f"Warning: Skipping invalid constraint: {e}")

        return cls(
            intent=intent,
            signature=signature,
            effects=effects,
            assertions=assertions,
            relationships=relationships,
            metadata=metadata,
            constraints=constraints,
        )


__all__ = [
    "HoleKind",
    "ProvenanceSource",
    "Provenance",
    "TypedHole",
    "IntentClause",
    "Parameter",
    "SigClause",
    "EffectClause",
    "AssertClause",
    "RelationshipClause",
    "Metadata",
    "IntermediateRepresentation",
]
